/**
 * @fileoverview Tests for config/gemini-hooks-generator module.
 *
 * Validates that Gemini CLI hooks are correctly generated with proper
 * event mappings, valid JavaScript, and no Claude-specific references.
 */

import { describe, it } from 'node:test';
import assert from 'node:assert/strict';
import { HOOK_MAP, generateAllGeminiHooks, generateGeminiSettings } from '../../src/config/gemini-hooks-generator.js';

// ---------------------------------------------------------------------------
// HOOK_MAP
// ---------------------------------------------------------------------------

describe('HOOK_MAP', () => {
  it('has 6 entries', () => {
    assert.equal(Object.keys(HOOK_MAP).length, 6);
  });

  it('maps prism-engine to BeforeModel', () => {
    assert.equal(HOOK_MAP['prism-engine'].event, 'BeforeModel');
  });

  it('maps model-governance to BeforeModel', () => {
    assert.equal(HOOK_MAP['model-governance'].event, 'BeforeModel');
  });

  it('maps mode-governance to BeforeTool', () => {
    assert.equal(HOOK_MAP['mode-governance'].event, 'BeforeTool');
  });

  it('maps constitution-guard to BeforeTool', () => {
    assert.equal(HOOK_MAP['constitution-guard'].event, 'BeforeTool');
  });

  it('maps read-protection to BeforeTool', () => {
    assert.equal(HOOK_MAP['read-protection'].event, 'BeforeTool');
  });

  it('maps session-digest to PreCompress', () => {
    assert.equal(HOOK_MAP['session-digest'].event, 'PreCompress');
  });

  it('every entry has a description', () => {
    for (const [name, config] of Object.entries(HOOK_MAP)) {
      assert.ok(config.description, `${name} should have a description`);
      assert.ok(config.description.length > 5, `${name} description should be meaningful`);
    }
  });
});

// ---------------------------------------------------------------------------
// generateAllGeminiHooks
// ---------------------------------------------------------------------------

describe('generateAllGeminiHooks', () => {
  const hooks = generateAllGeminiHooks();

  it('generates 6 hook files', () => {
    assert.equal(Object.keys(hooks).length, 6);
  });

  it('generates all expected filenames', () => {
    const expected = [
      'prism-engine.js',
      'model-governance.js',
      'mode-governance.js',
      'constitution-guard.js',
      'read-protection.js',
      'session-digest.js',
    ];
    for (const name of expected) {
      assert.ok(hooks[name], `Should generate ${name}`);
    }
  });

  it('all hooks are non-empty strings', () => {
    for (const [name, content] of Object.entries(hooks)) {
      assert.ok(typeof content === 'string', `${name} should be a string`);
      assert.ok(content.length > 100, `${name} should be non-trivial`);
    }
  });

  it('all hooks have shebang line', () => {
    for (const [name, content] of Object.entries(hooks)) {
      assert.ok(content.startsWith('#!/usr/bin/env node'), `${name} should have shebang`);
    }
  });

  it('all hooks have auto-generated header', () => {
    for (const [name, content] of Object.entries(hooks)) {
      assert.ok(content.includes('Auto-generated by chati.dev'), `${name} should have auto-generated header`);
    }
  });

  it('hooks do not reference Claude-specific APIs', () => {
    for (const [name, content] of Object.entries(hooks)) {
      assert.ok(!content.includes('PreToolUse'), `${name} should not reference PreToolUse (Claude event)`);
      assert.ok(!content.includes('UserPromptSubmit'), `${name} should not reference UserPromptSubmit (Claude event)`);
      assert.ok(!content.includes('PreCompact'), `${name} should not reference PreCompact (Claude event)`);
    }
  });

  it('mode-governance hook contains MODE_SCOPES', () => {
    assert.ok(hooks['mode-governance.js'].includes('MODE_SCOPES'));
    assert.ok(hooks['mode-governance.js'].includes('planning'));
    assert.ok(hooks['mode-governance.js'].includes('build'));
    assert.ok(hooks['mode-governance.js'].includes('deploy'));
  });

  it('constitution-guard hook contains DESTRUCTIVE_PATTERNS', () => {
    assert.ok(hooks['constitution-guard.js'].includes('DESTRUCTIVE_PATTERNS'));
    assert.ok(hooks['constitution-guard.js'].includes('rm'));
    assert.ok(hooks['constitution-guard.js'].includes('git'));
  });

  it('read-protection hook contains PROTECTED_FILES', () => {
    assert.ok(hooks['read-protection.js'].includes('PROTECTED_FILES'));
    assert.ok(hooks['read-protection.js'].includes('.env'));
    assert.ok(hooks['read-protection.js'].includes('.pem'));
  });

  it('read-protection hook allows safe patterns', () => {
    assert.ok(hooks['read-protection.js'].includes('.env.example'));
    assert.ok(hooks['read-protection.js'].includes('SAFE_FILES'));
  });

  it('session-digest hook references shared hook path', () => {
    assert.ok(hooks['session-digest.js'].includes("'session-digest.js'"),
      'Should reference session-digest.js filename');
    assert.ok(hooks['session-digest.js'].includes("'hooks'"),
      'Should reference hooks directory');
  });

  it('prism-engine hook references shared hook path', () => {
    assert.ok(hooks['prism-engine.js'].includes("'prism-engine.js'"),
      'Should reference prism-engine.js filename');
    assert.ok(hooks['prism-engine.js'].includes("'hooks'"),
      'Should reference hooks directory');
  });
});

// ---------------------------------------------------------------------------
// generateGeminiSettings
// ---------------------------------------------------------------------------

describe('generateGeminiSettings', () => {
  it('returns valid JSON', () => {
    const settings = generateGeminiSettings();
    const parsed = JSON.parse(settings);
    assert.ok(parsed, 'Should parse as JSON');
  });

  it('has hooks array', () => {
    const parsed = JSON.parse(generateGeminiSettings());
    assert.ok(Array.isArray(parsed.hooks));
  });

  it('has 6 hook entries', () => {
    const parsed = JSON.parse(generateGeminiSettings());
    assert.equal(parsed.hooks.length, 6);
  });

  it('has 2 BeforeModel hooks', () => {
    const parsed = JSON.parse(generateGeminiSettings());
    const beforeModel = parsed.hooks.filter(h => h.event === 'BeforeModel');
    assert.equal(beforeModel.length, 2);
  });

  it('has 3 BeforeTool hooks', () => {
    const parsed = JSON.parse(generateGeminiSettings());
    const beforeTool = parsed.hooks.filter(h => h.event === 'BeforeTool');
    assert.equal(beforeTool.length, 3);
  });

  it('has 1 PreCompress hook', () => {
    const parsed = JSON.parse(generateGeminiSettings());
    const preCompress = parsed.hooks.filter(h => h.event === 'PreCompress');
    assert.equal(preCompress.length, 1);
  });

  it('all hooks have path and event fields', () => {
    const parsed = JSON.parse(generateGeminiSettings());
    for (const hook of parsed.hooks) {
      assert.ok(hook.path, 'Should have path');
      assert.ok(hook.event, 'Should have event');
      assert.ok(hook.path.startsWith('.gemini/hooks/'), `Path should be in .gemini/hooks/: ${hook.path}`);
      assert.ok(hook.path.endsWith('.js'), `Path should end with .js: ${hook.path}`);
    }
  });
});
