/**
 * @fileoverview Context file generator for multi-CLI support.
 *
 * When alternative CLI providers are enabled, generates provider-specific
 * context files (GEMINI.md, AGENTS.md) derived from CLAUDE.md content.
 * Constitution Article XIX — context file generation is automatic.
 */

import { existsSync, readFileSync, writeFileSync } from 'fs';
import { join } from 'path';

// ---------------------------------------------------------------------------
// Replacement Maps
// ---------------------------------------------------------------------------

/**
 * Text replacements for Gemini CLI context file.
 * Transforms Claude Code-specific references into Gemini CLI equivalents.
 */
const GEMINI_REPLACEMENTS = [
  ['Claude Code', 'Gemini CLI'],
  ['claude code', 'Gemini CLI'],
  ['CLAUDE.md', 'GEMINI.md'],
  ['Claude.md', 'GEMINI.md'],
  ['.claude/commands/', '.gemini/agents/'],
  ['.claude/rules/', '.gemini/rules/'],
  ['.claude/mcp.json', '.gemini/settings.json'],
  ['claude --print', 'gemini --prompt'],
  ['claude -p', 'gemini --prompt'],
  ['CLAUDE.local.md', 'GEMINI.local.md'],
];

/**
 * Sections to strip from Codex CLI context file.
 * Codex does not support hooks, so hook-related content is removed.
 */
const CODEX_STRIP_PATTERNS = [
  /## (?:Hooks?|Hook System)[\s\S]*?(?=\n## |\n---|\n$)/gi,
  /- \*\*Hooks?\*\*:.*\n/gi,
  /hook[s]? \(.*?\)/gi,
];

/**
 * Text replacements for Codex CLI context file.
 */
const CODEX_REPLACEMENTS = [
  ['Claude Code', 'Codex CLI'],
  ['claude code', 'Codex CLI'],
  ['CLAUDE.md', 'AGENTS.md'],
  ['Claude.md', 'AGENTS.md'],
  ['.claude/commands/', '.codex/agents/'],
  ['.claude/rules/', '.codex/rules/'],
  ['.claude/mcp.json', '.codex/mcp.json'],
  ['claude --print', 'codex exec'],
  ['claude -p', 'codex exec'],
  ['CLAUDE.local.md', 'AGENTS.local.md'],
];

// ---------------------------------------------------------------------------
// Generators
// ---------------------------------------------------------------------------

/**
 * Generate GEMINI.md content from CLAUDE.md content.
 *
 * Adapts the content by replacing Claude Code-specific references with
 * Gemini CLI equivalents. Preserves structure and formatting.
 *
 * @param {string} content - Raw CLAUDE.md content
 * @returns {string} Adapted content for GEMINI.md
 */
export function generateGeminiMd(content) {
  let result = content;

  for (const [search, replace] of GEMINI_REPLACEMENTS) {
    result = result.replaceAll(search, replace);
  }

  // Prepend a header noting this file is auto-generated
  const header = [
    '<!-- Auto-generated by chati.dev from CLAUDE.md — do not edit manually -->',
    '',
  ].join('\n');

  return header + result;
}

/**
 * Generate AGENTS.md content from CLAUDE.md content.
 *
 * Simplifies the content for Codex CLI: strips hook references,
 * replaces CLI-specific paths, and produces a leaner context file
 * focused on code execution.
 *
 * @param {string} content - Raw CLAUDE.md content
 * @returns {string} Adapted content for AGENTS.md
 */
export function generateAgentsMd(content) {
  let result = content;

  // Strip hook-related sections (Codex has no hooks support)
  for (const pattern of CODEX_STRIP_PATTERNS) {
    result = result.replace(pattern, '');
  }

  // Apply text replacements
  for (const [search, replace] of CODEX_REPLACEMENTS) {
    result = result.replaceAll(search, replace);
  }

  // Clean up any double blank lines left by stripping
  result = result.replace(/\n{3,}/g, '\n\n');

  // Prepend a header noting this file is auto-generated
  const header = [
    '<!-- Auto-generated by chati.dev from CLAUDE.md — do not edit manually -->',
    '',
  ].join('\n');

  return header + result;
}

// ---------------------------------------------------------------------------
// Orchestrator
// ---------------------------------------------------------------------------

/**
 * Generate context files for all enabled alternative providers.
 *
 * Reads config.yaml to determine which providers are enabled, reads
 * CLAUDE.md from the project root, and writes the appropriate context
 * files (GEMINI.md, AGENTS.md) when their providers are active.
 *
 * @param {string} projectDir - Project root directory
 * @returns {{ generated: string[], skipped: string[], warning: string|null }}
 */
export function generateContextFiles(projectDir) {
  const result = { generated: [], skipped: [], warning: null };

  // Read CLAUDE.md
  const claudeMdPath = join(projectDir, 'CLAUDE.md');
  if (!existsSync(claudeMdPath)) {
    result.warning = 'CLAUDE.md not found — skipping context file generation';
    return result;
  }

  const claudeContent = readFileSync(claudeMdPath, 'utf-8');

  // Determine enabled providers from config.yaml
  const enabledProviders = resolveEnabledProviders(projectDir);

  // Provider-to-generator mapping
  const generators = {
    gemini: {
      filename: 'GEMINI.md',
      generate: generateGeminiMd,
    },
    codex: {
      filename: 'AGENTS.md',
      generate: generateAgentsMd,
    },
  };

  for (const [provider, config] of Object.entries(generators)) {
    if (enabledProviders.includes(provider)) {
      const outputPath = join(projectDir, config.filename);
      const content = config.generate(claudeContent);
      writeFileSync(outputPath, content, 'utf-8');
      result.generated.push(config.filename);
    } else {
      result.skipped.push(config.filename);
    }
  }

  return result;
}

// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------

/**
 * Resolve which alternative providers are enabled from config.yaml.
 *
 * Uses lightweight regex-based YAML extraction (no dependency on a
 * full YAML parser) consistent with cli-registry.js patterns.
 *
 * @param {string} projectDir - Project root directory
 * @returns {string[]} List of enabled provider names
 */
function resolveEnabledProviders(projectDir) {
  const configPath = join(projectDir, 'chati.dev', 'config.yaml');
  if (!existsSync(configPath)) {
    return [];
  }

  const raw = readFileSync(configPath, 'utf-8');
  const providers = ['gemini', 'codex', 'copilot'];
  const enabled = [];

  for (const name of providers) {
    const match = raw.match(new RegExp(`${name}:[\\s\\S]*?enabled:\\s*(true|false)`, 'm'));
    if (match && match[1] === 'true') {
      enabled.push(name);
    }
  }

  return enabled;
}
