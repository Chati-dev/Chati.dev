/**
 * @fileoverview Context file generator for multi-CLI support.
 *
 * When alternative CLI providers are enabled, generates provider-specific
 * context files (GEMINI.md, AGENTS.md) derived from CLAUDE.md content.
 * Constitution Article XIX — context file generation is automatic.
 *
 * Provider conventions (verified Feb 2026):
 * - Gemini CLI: auto-loads GEMINI.md, uses .gemini/commands/*.toml, no rules/
 * - Codex CLI:  auto-loads AGENTS.md, uses .agents/skills/chati/SKILL.md for $chati
 */

import { existsSync, readFileSync, writeFileSync } from 'fs';
import { join } from 'path';
import { getEnabledNonClaudeProviders } from '../utils/config-parser.js';

// ---------------------------------------------------------------------------
// Replacement Maps
// ---------------------------------------------------------------------------

/**
 * Text replacements for Gemini CLI context file.
 * Transforms Claude Code-specific references into Gemini CLI equivalents.
 * Note: Gemini has no rules/ directory — references point to chati.dev/context/.
 */
const GEMINI_REPLACEMENTS = [
  ['Claude Code', 'Gemini CLI'],
  ['claude code', 'Gemini CLI'],
  ['CLAUDE.md', 'GEMINI.md'],
  ['Claude.md', 'GEMINI.md'],
  ['.claude/commands/', '.gemini/commands/'],
  ['.claude/rules/chati/', '.gemini/context/'],
  ['.claude/rules/', '.gemini/context/'],
  ['.claude/mcp.json', '.gemini/settings.json'],
  ['claude --print', 'gemini --prompt'],
  ['claude -p', 'gemini --prompt'],
  ['CLAUDE.local.md', '.gemini/session-lock.md'],
];

/**
 * Sections to strip from Codex CLI context file.
 * Codex does not support hooks, so hook-related content is removed.
 */
const CODEX_STRIP_PATTERNS = [
  /## (?:Hooks?|Hook System)[\s\S]*?(?=\n## |\n---|\n$)/gi,
  /- \*\*Hooks?\*\*:.*\n/gi,
  /hook[s]? \(.*?\)/gi,
];

/**
 * Text replacements for Codex CLI context file.
 * Note: Codex has no commands/ or rules/ directories — references point to chati.dev/.
 */
const CODEX_REPLACEMENTS = [
  ['Claude Code', 'Codex CLI'],
  ['claude code', 'Codex CLI'],
  ['CLAUDE.md', 'AGENTS.md'],
  ['Claude.md', 'AGENTS.md'],
  ['.claude/commands/', 'chati.dev/orchestrator/'],
  ['.claude/rules/chati/', 'chati.dev/context/'],
  ['.claude/rules/', 'chati.dev/context/'],
  ['.claude/mcp.json', '.codex/config.toml'],
  ['claude --print', 'codex exec'],
  ['claude -p', 'codex exec'],
  ['CLAUDE.local.md', 'AGENTS.override.md'],
  ['/chati', '$chati'],
];

// ---------------------------------------------------------------------------
// Generators
// ---------------------------------------------------------------------------

/**
 * @import directives appended to GEMINI.md.
 * Gemini CLI resolves @import automatically, loading the full governance
 * context chain + session lock — equivalent to Claude Code's rules/ + CLAUDE.local.md.
 */
const GEMINI_IMPORTS = [
  '@import .gemini/context/root.md',
  '@import .gemini/context/governance.md',
  '@import .gemini/context/protocols.md',
  '@import .gemini/context/quality.md',
  '@import .gemini/session-lock.md',
];

/**
 * Generate GEMINI.md content from CLAUDE.md content.
 *
 * Adapts the content by replacing Claude Code-specific references with
 * Gemini CLI equivalents, then appends @import directives so Gemini CLI
 * auto-loads governance rules and session lock (context parity with Claude).
 *
 * @param {string} content - Raw CLAUDE.md content
 * @returns {string} Adapted content for GEMINI.md
 */
export function generateGeminiMd(content) {
  let result = content;

  for (const [search, replace] of GEMINI_REPLACEMENTS) {
    result = result.replaceAll(search, replace);
  }

  // Prepend a header noting this file is auto-generated
  const header = [
    '<!-- Auto-generated by chati.dev from CLAUDE.md — do not edit manually -->',
    '',
  ].join('\n');

  // Append @import directives for context parity
  const imports = '\n' + GEMINI_IMPORTS.join('\n') + '\n';

  return header + result + imports;
}

/**
 * Generate AGENTS.md content from CLAUDE.md content.
 *
 * Simplifies the content for Codex CLI: strips hook references,
 * replaces CLI-specific paths, and produces a leaner context file
 * focused on code execution. When contextFiles are provided, inlines
 * governance/protocols/quality for full context parity with Claude Code.
 *
 * @param {string} content - Raw CLAUDE.md content
 * @param {object} [contextFiles] - Optional inline context { root, governance, protocols, quality }
 * @returns {string} Adapted content for AGENTS.md
 */
export function generateAgentsMd(content, contextFiles = null) {
  let result = content;

  // Strip hook-related sections (Codex has no hooks support)
  for (const pattern of CODEX_STRIP_PATTERNS) {
    result = result.replace(pattern, '');
  }

  // Apply text replacements
  for (const [search, replace] of CODEX_REPLACEMENTS) {
    result = result.replaceAll(search, replace);
  }

  // Clean up any double blank lines left by stripping
  result = result.replace(/\n{3,}/g, '\n\n');

  // Prepend a header noting this file is auto-generated
  const header = [
    '<!-- Auto-generated by chati.dev from CLAUDE.md — do not edit manually -->',
    '',
  ].join('\n');

  result = header + result;

  // Inline context files for full governance parity (Codex has no @import)
  if (contextFiles) {
    const sections = [];
    for (const [name, fileContent] of Object.entries(contextFiles)) {
      if (fileContent) {
        // Adapt context for Codex (replace Claude-specific refs)
        let adapted = fileContent;
        for (const [search, replace] of CODEX_REPLACEMENTS) {
          adapted = adapted.replaceAll(search, replace);
        }
        sections.push(adapted.trim());
      }
    }
    if (sections.length > 0) {
      result += '\n---\n\n' + sections.join('\n\n---\n\n') + '\n';
    }
  }

  return result;
}

// ---------------------------------------------------------------------------
// Orchestrator
// ---------------------------------------------------------------------------

/**
 * Context file names that provide governance parity across CLIs.
 * These are read from chati.dev/context/ and inlined into AGENTS.md for Codex.
 */
const CONTEXT_FILES = ['root.md', 'governance.md', 'protocols.md', 'quality.md'];

/**
 * Generate context files for all enabled alternative providers.
 *
 * Reads config.yaml to determine which providers are enabled, reads
 * CLAUDE.md from the project root, and writes the appropriate context
 * files (GEMINI.md, AGENTS.md) when their providers are active.
 *
 * For Codex, governance context files are inlined into AGENTS.md to provide
 * the same rules awareness that Claude gets from .claude/rules/chati/.
 *
 * @param {string} projectDir - Project root directory
 * @param {string} [baseContent] - Optional base content (used when CLAUDE.md doesn't exist on disk)
 * @returns {{ generated: string[], skipped: string[], warning: string|null }}
 */
export function generateContextFiles(projectDir, baseContent = null) {
  const result = { generated: [], skipped: [], warning: null };

  // Use provided base content or read CLAUDE.md from disk
  let claudeContent = baseContent;
  if (!claudeContent) {
    const claudeMdPath = join(projectDir, 'CLAUDE.md');
    if (!existsSync(claudeMdPath)) {
      result.warning = 'CLAUDE.md not found and no base content provided — skipping context file generation';
      return result;
    }
    claudeContent = readFileSync(claudeMdPath, 'utf-8');
  }

  // Determine enabled providers from config.yaml
  const enabledProviders = resolveEnabledProviders(projectDir);

  // Read context files for inline injection (Codex)
  const contextFiles = readContextFilesFromDisk(projectDir);

  // Provider-to-generator mapping
  const generators = {
    gemini: {
      filename: 'GEMINI.md',
      generate: (content) => generateGeminiMd(content),
    },
    codex: {
      filename: 'AGENTS.md',
      generate: (content) => generateAgentsMd(content, contextFiles),
    },
  };

  for (const [provider, config] of Object.entries(generators)) {
    if (enabledProviders.includes(provider)) {
      const outputPath = join(projectDir, config.filename);
      const content = config.generate(claudeContent);
      writeFileSync(outputPath, content, 'utf-8');
      result.generated.push(config.filename);
    } else {
      result.skipped.push(config.filename);
    }
  }

  return result;
}

/**
 * Read context files from chati.dev/context/ for inline injection.
 * Returns null if no context files found (backward compat).
 *
 * @param {string} projectDir - Project root directory
 * @returns {object|null} { root, governance, protocols, quality } or null
 */
function readContextFilesFromDisk(projectDir) {
  const contextDir = join(projectDir, 'chati.dev', 'context');
  if (!existsSync(contextDir)) return null;

  const files = {};
  let found = false;
  for (const file of CONTEXT_FILES) {
    const filePath = join(contextDir, file);
    if (existsSync(filePath)) {
      const key = file.replace('.md', '');
      files[key] = readFileSync(filePath, 'utf-8');
      found = true;
    }
  }
  return found ? files : null;
}

// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------

/**
 * Resolve which alternative providers are enabled from config.yaml.
 * Delegates to shared config parser utility.
 *
 * @param {string} projectDir - Project root directory
 * @returns {string[]} List of enabled non-Claude provider names
 */
function resolveEnabledProviders(projectDir) {
  return getEnabledNonClaudeProviders(projectDir);
}
